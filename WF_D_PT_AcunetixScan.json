{
  "name": "WF_D_PT_AcunetixScan",
  "nodes": [
    {
      "parameters": {},
      "id": "d-trigger",
      "name": "Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        -1180,
        160
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/?tags=targets:ready&limit=1000' }}",
        "options": {}
      },
      "id": "d-products",
      "name": "Get PT Targets/Products",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -980,
        160
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "return [{\"json\": {\"pool_probe\": \"started\"}}]"
      },
      "id": "d-acu-scans",
      "name": "Get Active Acunetix Scans",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -760,
        160
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import os\nimport json\nimport urllib.request\nimport urllib.error\nimport hashlib\n\nACTIVE_STATUSES = {'processing', 'scheduled', 'queued', 'starting'}\n\n\ndef parse_positive_int(value, default):\n    try:\n        parsed = int(value)\n        if parsed > 0:\n            return parsed\n    except Exception:\n        pass\n    return default\n\n\ndef parse_bool(value, default=False):\n    if value is None:\n        return default\n    if isinstance(value, bool):\n        return value\n    raw = str(value).strip().lower()\n    if raw in {'1', 'true', 'yes', 'y', 'on'}:\n        return True\n    if raw in {'0', 'false', 'no', 'n', 'off'}:\n        return False\n    return default\n\n\ndef normalize_policy(value):\n    raw = str(value or '').strip().lower()\n    return raw if raw in {'least_loaded', 'weighted'} else 'least_loaded'\n\n\ndef parse_instances():\n    default_limit = parse_positive_int(os.environ.get('ACUNETIX_MAX_SCANS_PER_NODE'), 5)\n    raw = (os.environ.get('ACUNETIX_INSTANCES_JSON') or '').strip()\n    instances = []\n    if raw:\n        try:\n            arr = json.loads(raw)\n            if isinstance(arr, list):\n                for idx, item in enumerate(arr):\n                    if not isinstance(item, dict):\n                        continue\n                    endpoint = str(item.get('endpoint') or '').strip().rstrip('/')\n                    token = str(item.get('token') or '').strip()\n                    if not endpoint or not token:\n                        continue\n                    node_limit = parse_positive_int(\n                        item.get('max_scans_per_node', item.get('scan_limit', default_limit)),\n                        default_limit,\n                    )\n                    weight = parse_positive_int(item.get('weight', 1), 1)\n                    instances.append({\n                        'name': item.get('name') or f'acu-{idx+1}',\n                        'endpoint': endpoint,\n                        'token': token,\n                        'max_scans_per_node': node_limit,\n                        'weight': weight,\n                    })\n        except Exception:\n            pass\n    if not instances:\n        endpoint = (os.environ.get('ACUNETIX_BASE_URL') or 'https://localhost:3443').strip().rstrip('/')\n        token = (os.environ.get('ACUNETIX_API_KEY') or '').strip()\n        if token:\n            instances.append({\n                'name': 'acu-default',\n                'endpoint': endpoint,\n                'token': token,\n                'max_scans_per_node': default_limit,\n                'weight': 1,\n            })\n    return instances\n\n\ndef http_json(url, token, timeout=8):\n    req = urllib.request.Request(url)\n    req.add_header('X-Auth', token)\n    with urllib.request.urlopen(req, timeout=timeout) as resp:\n        data = resp.read().decode('utf-8')\n        return getattr(resp, 'status', 200), json.loads(data) if data else {}\n\n\ndef pick_by_policy(candidates, policy):\n    if not candidates:\n        return None\n    if policy == 'weighted':\n        return sorted(\n            candidates,\n            key=lambda n: (\n                (n['active_sessions'] + n['planned']) / max(1, int(n.get('weight', 1))),\n                n['active_sessions'] + n['planned'],\n                n['name'],\n            ),\n        )[0]\n    return sorted(\n        candidates,\n        key=lambda n: (\n            n['active_sessions'] + n['planned'],\n            n['active_sessions'],\n            n['planned'],\n            n['name'],\n        ),\n    )[0]\n\n\ndef sticky_node_for_pt(pt_id, nodes):\n    ordered = sorted(nodes, key=lambda n: n['name'])\n    if not ordered:\n        return None\n    digest = hashlib.sha256(str(pt_id).encode('utf-8')).hexdigest()\n    index = int(digest[:8], 16) % len(ordered)\n    return ordered[index]['name']\n\n\ntrigger_input = $node['Trigger'].json if isinstance($node['Trigger'].json, dict) else {}\ntrigger_product_type_id = trigger_input.get('product_type_id')\ntrigger_domain = trigger_input.get('domain')\ntry:\n    trigger_product_type_id = int(trigger_product_type_id) if trigger_product_type_id is not None else None\nexcept Exception:\n    trigger_product_type_id = None\n\nselection_policy = normalize_policy(os.environ.get('ACUNETIX_NODE_SELECTION_POLICY'))\nsticky_assignment = parse_bool(os.environ.get('ACUNETIX_STICKY_ASSIGNMENT', 'true'), True)\nfairness_policy = 'round_robin_by_pt'\n\nproducts = ($node['Get PT Targets/Products'].json.get('results') or [])\neligible = []\nfor p in products:\n    if not isinstance(p, dict):\n        continue\n    try:\n        product_type_id = int(p.get('prod_type'))\n    except Exception:\n        continue\n    if trigger_product_type_id is not None and product_type_id != trigger_product_type_id:\n        continue\n    tags = p.get('tags') or []\n    if not isinstance(tags, list):\n        tags = [str(tags)]\n    if 'targets:ready' in tags and 'acunetix:active' not in tags:\n        eligible.append({\n            'product_id': p.get('id'),\n            'product_name': p.get('name'),\n            'product_type_id': product_type_id,\n            'domain': trigger_domain,\n        })\n\n# Fairness: round-robin by PT so one PT does not consume all slots.\npt_queues = {}\nfor item in sorted(eligible, key=lambda x: (int(x.get('product_id') or 0), int(x.get('product_type_id') or 0))):\n    pt_queues.setdefault(int(item['product_type_id']), []).append(item)\npt_order = sorted(pt_queues.keys())\n\ninstances = parse_instances()\nnode_reports = []\navailable_nodes = []\ntotal_active = 0\nfor node in instances:\n    report = dict(node)\n    try:\n        status, _ = http_json(node['endpoint'] + '/api/v1/me', node['token'])\n        if status < 200 or status > 299:\n            raise Exception(f'health_status_{status}')\n        _, scans = http_json(node['endpoint'] + '/api/v1/scans?l=100', node['token'])\n        active_sessions = 0\n        for s in scans.get('scans', []) or []:\n            st = (s.get('current_session') or {}).get('status', '')\n            if st in ACTIVE_STATUSES:\n                active_sessions += 1\n        free_slots = max(0, int(node['max_scans_per_node']) - active_sessions)\n        report.update({\n            'healthy': True,\n            'active_sessions': active_sessions,\n            'free_slots': free_slots,\n        })\n        total_active += active_sessions\n        if free_slots > 0:\n            available_nodes.append({**node, 'active_sessions': active_sessions, 'free_slots': free_slots, 'planned': 0})\n    except Exception as e:\n        report.update({'healthy': False, 'active_sessions': None, 'free_slots': 0, 'error': str(e)})\n    node_reports.append(report)\n\nselected = []\nselected_by_pt = {}\nif available_nodes and pt_order:\n    cursor = 0\n    while True:\n        candidates = [n for n in available_nodes if n['free_slots'] > 0]\n        if not candidates:\n            break\n        active_pts = [pt for pt in pt_order if pt_queues.get(pt)]\n        if not active_pts:\n            break\n\n        pt_id = active_pts[cursor % len(active_pts)]\n        cursor += 1\n        item = pt_queues[pt_id].pop(0)\n\n        chosen = None\n        sticky_name = None\n        if sticky_assignment:\n            sticky_name = sticky_node_for_pt(pt_id, candidates)\n            if sticky_name:\n                sticky_candidate = next((n for n in candidates if n['name'] == sticky_name), None)\n                if sticky_candidate is not None:\n                    chosen = sticky_candidate\n\n        if chosen is None:\n            chosen = pick_by_policy(candidates, selection_policy)\n\n        if chosen is None:\n            break\n\n        item.update({\n            'acunetix_node_name': chosen['name'],\n            'acunetix_endpoint': chosen['endpoint'],\n            'acunetix_token': chosen['token'],\n            'dispatch_policy': {\n                'fairness': fairness_policy,\n                'node_selection': selection_policy,\n                'sticky_assignment': sticky_assignment,\n                'sticky_node_name': sticky_name if sticky_assignment else None,\n            },\n        })\n        selected.append(item)\n        selected_by_pt[str(pt_id)] = int(selected_by_pt.get(str(pt_id), 0)) + 1\n        chosen['planned'] += 1\n        chosen['free_slots'] -= 1\n\nreturn [{\n  'json': {\n    'active_scans': total_active,\n    'scan_limit': sum(int(n.get('max_scans_per_node', 0)) for n in instances),\n    'available_slots': sum(max(0, int(n.get('free_slots', 0))) for n in node_reports if n.get('healthy')),\n    'dispatch_count': len(selected),\n    'dispatch_items': selected,\n    'dispatch_by_pt': selected_by_pt,\n    'dispatch_policy': {\n        'fairness': fairness_policy,\n        'node_selection': selection_policy,\n        'sticky_assignment': sticky_assignment,\n    },\n    'acunetix_pool': node_reports,\n  }\n}]"
      },
      "id": "d-plan",
      "name": "Build Dispatch Plan (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -540,
        160
      ]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.dispatch_count }}",
              "operation": "larger",
              "value2": 0
            }
          ]
        }
      },
      "id": "d-if",
      "name": "Has capacity and products?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -340,
        160
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "out = []\nfor row in $json.get('dispatch_items', []):\n    if not isinstance(row, dict):\n        continue\n    out.append({'json': {\n        'product_id': row.get('product_id'),\n        'product_name': row.get('product_name'),\n        'product_type_id': row.get('product_type_id'),\n        'domain': row.get('domain'),\n        'acunetix_node_name': row.get('acunetix_node_name'),\n        'acunetix_endpoint': row.get('acunetix_endpoint'),\n        'acunetix_token': row.get('acunetix_token'),\n    }})\nreturn out"
      },
      "id": "d-expand",
      "name": "Expand Dispatch Items",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -120,
        80
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_D_ProductScan",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "d-run-product",
      "name": "Run WF_D_ProductScan",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        100,
        80
      ],
      "continueOnFail": false
    }
  ],
  "connections": {
    "Trigger": {
      "main": [
        [
          {
            "node": "Get PT Targets/Products",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get PT Targets/Products": {
      "main": [
        [
          {
            "node": "Get Active Acunetix Scans",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Active Acunetix Scans": {
      "main": [
        [
          {
            "node": "Build Dispatch Plan (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Dispatch Plan (Python)": {
      "main": [
        [
          {
            "node": "Has capacity and products?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has capacity and products?": {
      "main": [
        [
          {
            "node": "Expand Dispatch Items",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Expand Dispatch Items": {
      "main": [
        [
          {
            "node": "Run WF_D_ProductScan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": []
}
