{
  "name": "WF_Dojo_Master",
  "nodes": [
    {
      "parameters": {},
      "id": "m-trigger",
      "name": "Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        -1400,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/product_types/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-product-types",
      "name": "Get Product Types",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1360,
        100
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-products",
      "name": "Get Products",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1180,
        100
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from collections import defaultdict\n\nfirst_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef read_key(container, key, default=None):\n    try:\n        value = container.get(key)\n        return default if value is None else value\n    except Exception:\n        try:\n            value = container[key]\n            return default if value is None else value\n        except Exception:\n            return default\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\ndef to_container(value):\n    if value is None:\n        return {}\n    if isinstance(value, list):\n        return value[0] if value else {}\n    try:\n        first = value[0]\n        if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n            return first\n    except Exception:\n        pass\n    return value\n\ndef is_mapping_like(value):\n    return hasattr(value, 'get') or hasattr(value, '__getitem__')\n\nincoming = to_container(payload)\ntrigger_input = to_container(read_key(incoming, 'trigger', {}))\n\ntrigger_product_type_id = read_key(trigger_input, 'product_type_id')\ntrigger_domain = read_key(trigger_input, 'domain')\n\ntry:\n    trigger_product_type_id = int(trigger_product_type_id) if trigger_product_type_id is not None else None\nexcept Exception:\n    trigger_product_type_id = None\n\nproducts = to_list(read_key(incoming, 'products', []))\nproduct_types = to_list(read_key(incoming, 'product_types', []))\n\ndef as_tag_set(raw_tags):\n    if isinstance(raw_tags, list):\n        return set(str(t) for t in raw_tags)\n    if raw_tags is None:\n        return set()\n    try:\n        return set(str(t) for t in raw_tags)\n    except Exception:\n        return {str(raw_tags)}\n\npt_by_id = {}\nfor pt in product_types:\n    if not is_mapping_like(pt):\n        continue\n    pt_id = read_key(pt, 'id')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    pt_by_id[pt_id] = pt\n\nproducts_by_pt = defaultdict(list)\nfor p in products:\n    if not is_mapping_like(p):\n        continue\n    pt_id = read_key(p, 'prod_type')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    products_by_pt[pt_id].append(p)\n    if pt_id not in pt_by_id:\n        pt_by_id[pt_id] = {'id': pt_id, 'name': f'PT #{pt_id}', 'tags': []}\n\nall_pt_ids = sorted(pt_by_id.keys())\nif trigger_product_type_id is not None:\n    all_pt_ids = [pt_id for pt_id in all_pt_ids if pt_id == trigger_product_type_id]\n\nqueue_wf_a_subdomains_pt = []\nqueue_wf_b_nmap_product = []\nqueue_wf_c_targets_for_pt = []\nqueue_wf_d_pt_acunetixscan = []\n\nfor pt_id in all_pt_ids:\n    pt = pt_by_id.get(pt_id) or {}\n    pt_tags = as_tag_set(read_key(pt, 'tags', []))\n    pt_products = products_by_pt.get(pt_id, [])\n\n    normalized_products = []\n    for p in sorted(pt_products, key=lambda x: int(read_key(x, 'id', 0) or 0)):\n        product_id = read_key(p, 'id')\n        try:\n            product_id = int(product_id)\n        except Exception:\n            continue\n\n        tags = as_tag_set(read_key(p, 'tags', []))\n        needs_nmap = 'needs:nmap' in tags\n        nmap_done = ('nmap:done' in tags) or ('nmap:completed' in tags)\n        targets_ready = 'targets:ready' in tags\n        active_scan = 'acunetix:active' in tags\n\n        norm = {\n            'product_id': product_id,\n            'product_name': read_key(p, 'name'),\n            'product_type_id': pt_id,\n            'needs_nmap': needs_nmap,\n            'nmap_done': nmap_done,\n            'targets_ready': targets_ready,\n            'active_scan': active_scan,\n        }\n        normalized_products.append(norm)\n\n        if needs_nmap and not nmap_done:\n            queue_wf_b_nmap_product.append({\n                'product_id': product_id,\n                'product_name': read_key(p, 'name'),\n                'product_type_id': pt_id,\n                'domain': trigger_domain,\n            })\n\n    if len(normalized_products) == 0:\n        queue_wf_a_subdomains_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': read_key(pt, 'name'),\n            'domain': trigger_domain,\n        })\n        continue\n\n    needs_nmap_products = [p for p in normalized_products if p['needs_nmap']]\n    has_needs_nmap = len(needs_nmap_products) > 0\n    nmap_completed_for_all_needed = all(p['nmap_done'] for p in needs_nmap_products)\n    product_targets_ready_tag = any(p['targets_ready'] for p in normalized_products)\n\n    # Rule: enqueue PT for Targets only when there are Products with needs:nmap and all of them are nmap-done,\n    # or when an explicit readiness tag exists on Product (targets:ready).\n    if (has_needs_nmap and nmap_completed_for_all_needed) or product_targets_ready_tag:\n        queue_wf_c_targets_for_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': read_key(pt, 'name'),\n            'domain': trigger_domain,\n        })\n\n    pt_targets_ready = ('targets:ready' in pt_tags) or any(p['targets_ready'] for p in normalized_products)\n    pt_has_active_scan = ('acunetix:active' in pt_tags) or any(p['active_scan'] for p in normalized_products)\n\n    if pt_targets_ready and not pt_has_active_scan:\n        queue_wf_d_pt_acunetixscan.append({\n            'product_type_id': pt_id,\n            'product_type_name': read_key(pt, 'name'),\n            'domain': trigger_domain,\n        })\n\nreturn [{\n    'json': {\n        'run_subdomains': len(queue_wf_a_subdomains_pt) > 0,\n        'run_nmap': len(queue_wf_b_nmap_product) > 0,\n        'run_targets': len(queue_wf_c_targets_for_pt) > 0,\n        'run_acunetix': len(queue_wf_d_pt_acunetixscan) > 0,\n        'queue_wf_a_subdomains_pt': queue_wf_a_subdomains_pt,\n        'queue_wf_b_nmap_product': queue_wf_b_nmap_product,\n        'queue_wf_c_targets_for_pt': queue_wf_c_targets_for_pt,\n        'queue_wf_d_pt_acunetixscan': queue_wf_d_pt_acunetixscan,\n        'products_grouped_by_prod_type': {str(k): v for k, v in products_by_pt.items()},\n        'trigger_product_type_id': trigger_product_type_id,\n        'trigger_domain': trigger_domain,\n    }\n}]"
      },
      "id": "m-plan",
      "name": "Build Plan (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -950,
        100
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.run_subdomains}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "m-if-subdomains",
      "name": "Need WF_A_Subdomains_PT?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -760,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_A_Subdomains_PT",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-a",
      "name": "Run WF_A_Subdomains_PT",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        -460,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.run_nmap}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "m-if-nmap",
      "name": "Need WF_B_Nmap_Product?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -340,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_B_Nmap_Product",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-b",
      "name": "Run WF_B_Nmap_Product",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        -40,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.run_targets}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "m-if-targets",
      "name": "Need WF_C_Targets_For_PT?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        60,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_C_Targets_For_PT",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-c",
      "name": "Run WF_C_Targets_For_PT",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        360,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.run_acunetix}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "m-if-acu",
      "name": "Need WF_D_PT_AcunetixScan?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        460,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_D_PT_AcunetixScan",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-d",
      "name": "Run WF_D_PT_AcunetixScan",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        670,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef read_key(container, key, default=None):\n    try:\n        value = container.get(key)\n        return default if value is None else value\n    except Exception:\n        try:\n            value = container[key]\n            return default if value is None else value\n        except Exception:\n            return default\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\ndef to_container(value):\n    if value is None:\n        return {}\n    if isinstance(value, list):\n        return value[0] if value else {}\n    try:\n        first = value[0]\n        if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n            return first\n    except Exception:\n        pass\n    return value\n\ndef is_mapping_like(value):\n    return hasattr(value, 'get') or hasattr(value, '__getitem__')\n\nincoming = to_container(payload)\nout = []\nfor row in to_list(read_key(incoming, 'queue_wf_a_subdomains_pt', [])):\n    if not is_mapping_like(row):\n        continue\n    item = {}\n    item['product_type_id'] = read_key(row, 'product_type_id')\n    item['product_type_name'] = read_key(row, 'product_type_name')\n    item['domain'] = read_key(row, 'domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-a",
      "name": "Expand WF_A Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef read_key(container, key, default=None):\n    try:\n        value = container.get(key)\n        return default if value is None else value\n    except Exception:\n        try:\n            value = container[key]\n            return default if value is None else value\n        except Exception:\n            return default\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\ndef to_container(value):\n    if value is None:\n        return {}\n    if isinstance(value, list):\n        return value[0] if value else {}\n    try:\n        first = value[0]\n        if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n            return first\n    except Exception:\n        pass\n    return value\n\ndef is_mapping_like(value):\n    return hasattr(value, 'get') or hasattr(value, '__getitem__')\n\nincoming = to_container(payload)\nout = []\nfor row in to_list(read_key(incoming, 'queue_wf_b_nmap_product', [])):\n    if not is_mapping_like(row):\n        continue\n    item = {}\n    item['product_id'] = read_key(row, 'product_id')\n    item['product_name'] = read_key(row, 'product_name')\n    item['product_type_id'] = read_key(row, 'product_type_id')\n    item['domain'] = read_key(row, 'domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-b",
      "name": "Expand WF_B Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef read_key(container, key, default=None):\n    try:\n        value = container.get(key)\n        return default if value is None else value\n    except Exception:\n        try:\n            value = container[key]\n            return default if value is None else value\n        except Exception:\n            return default\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\ndef to_container(value):\n    if value is None:\n        return {}\n    if isinstance(value, list):\n        return value[0] if value else {}\n    try:\n        first = value[0]\n        if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n            return first\n    except Exception:\n        pass\n    return value\n\ndef is_mapping_like(value):\n    return hasattr(value, 'get') or hasattr(value, '__getitem__')\n\nincoming = to_container(payload)\nout = []\nfor row in to_list(read_key(incoming, 'queue_wf_c_targets_for_pt', [])):\n    if not is_mapping_like(row):\n        continue\n    item = {}\n    item['product_type_id'] = read_key(row, 'product_type_id')\n    item['product_type_name'] = read_key(row, 'product_type_name')\n    item['domain'] = read_key(row, 'domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-c",
      "name": "Expand WF_C Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef read_key(container, key, default=None):\n    try:\n        value = container.get(key)\n        return default if value is None else value\n    except Exception:\n        try:\n            value = container[key]\n            return default if value is None else value\n        except Exception:\n            return default\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\ndef to_container(value):\n    if value is None:\n        return {}\n    if isinstance(value, list):\n        return value[0] if value else {}\n    try:\n        first = value[0]\n        if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n            return first\n    except Exception:\n        pass\n    return value\n\ndef is_mapping_like(value):\n    return hasattr(value, 'get') or hasattr(value, '__getitem__')\n\nincoming = to_container(payload)\nout = []\nfor row in to_list(read_key(incoming, 'queue_wf_d_pt_acunetixscan', [])):\n    if not is_mapping_like(row):\n        continue\n    item = {}\n    item['product_type_id'] = read_key(row, 'product_type_id')\n    item['product_type_name'] = read_key(row, 'product_type_name')\n    item['domain'] = read_key(row, 'domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-d",
      "name": "Expand WF_D Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nitem = first_item.json if first_item else {}\nif not isinstance(item, dict):\n    item = {}\nreturn [{'json': {'trigger': item}}]"
      },
      "id": "m-prepare-trigger",
      "name": "Prepare Trigger Input (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1170,
        -80
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef get_results(container):\n    # Read container['results'] as softly as possible (dict/proxy/mapping/list-item).\n    try:\n        return container.get('results')\n    except Exception:\n        try:\n            return container['results']\n        except Exception:\n            return None\n\ndef to_list(x):\n    if x is None:\n        return []\n    if isinstance(x, list):\n        return x\n    # n8n may expose a proxy list: not list, but iterable.\n    try:\n        return [v for v in x]\n    except Exception:\n        return []\n\ncontainer = None\n\nif payload is None:\n    container = {}\nelse:\n    # If payload is a list-like root, take the first element as container.\n    if isinstance(payload, list):\n        container = payload[0] if payload else {}\n    else:\n        try:\n            first = payload[0]\n            if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n                container = first\n            else:\n                container = payload\n        except Exception:\n            container = payload\n\nresults_raw = get_results(container) if container is not None else None\nresults = to_list(results_raw)\n\nreturn [{'json': {'product_types': results}}]"
      },
      "id": "m-prepare-pt",
      "name": "Prepare Product Types (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        -80
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef get_results(container):\n    # Read container['results'] as softly as possible (dict/proxy/mapping/list-item).\n    try:\n        return container.get('results')\n    except Exception:\n        try:\n            return container['results']\n        except Exception:\n            return None\n\ndef to_list(x):\n    if x is None:\n        return []\n    if isinstance(x, list):\n        return x\n    # n8n may expose a proxy list: not list, but iterable.\n    try:\n        return [v for v in x]\n    except Exception:\n        return []\n\ncontainer = None\n\nif payload is None:\n    container = {}\nelse:\n    # If payload is a list-like root, take the first element as container.\n    if isinstance(payload, list):\n        container = payload[0] if payload else {}\n    else:\n        try:\n            first = payload[0]\n            if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n                container = first\n            else:\n                container = payload\n        except Exception:\n            container = payload\n\nresults_raw = get_results(container) if container is not None else None\nresults = to_list(results_raw)\n\nreturn [{'json': {'products': results}}]"
      },
      "id": "m-prepare-products",
      "name": "Prepare Products (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -740,
        280
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-trigger-pt",
      "name": "Merge Trigger + Product Types",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -740,
        -80
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-build-input",
      "name": "Merge Build Plan Input",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -520,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/product_types/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-product-types-after-a",
      "name": "Get Product Types After WF_A",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -300,
        -260
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-products-after-a",
      "name": "Get Products After WF_A",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -300,
        -120
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef get_results(container):\n    # Read container['results'] as softly as possible (dict/proxy/mapping/list-item).\n    try:\n        return container.get('results')\n    except Exception:\n        try:\n            return container['results']\n        except Exception:\n            return None\n\ndef to_list(x):\n    if x is None:\n        return []\n    if isinstance(x, list):\n        return x\n    # n8n may expose a proxy list: not list, but iterable.\n    try:\n        return [v for v in x]\n    except Exception:\n        return []\n\ncontainer = None\n\nif payload is None:\n    container = {}\nelse:\n    # If payload is a list-like root, take the first element as container.\n    if isinstance(payload, list):\n        container = payload[0] if payload else {}\n    else:\n        try:\n            first = payload[0]\n            if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n                container = first\n            else:\n                container = payload\n        except Exception:\n            container = payload\n\nresults_raw = get_results(container) if container is not None else None\nresults = to_list(results_raw)\n\nreturn [{'json': {'product_types': results}}]"
      },
      "id": "m-prepare-pt-after-a",
      "name": "Prepare Product Types After WF_A (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -60,
        -260
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef get_results(container):\n    # Read container['results'] as softly as possible (dict/proxy/mapping/list-item).\n    try:\n        return container.get('results')\n    except Exception:\n        try:\n            return container['results']\n        except Exception:\n            return None\n\ndef to_list(x):\n    if x is None:\n        return []\n    if isinstance(x, list):\n        return x\n    # n8n may expose a proxy list: not list, but iterable.\n    try:\n        return [v for v in x]\n    except Exception:\n        return []\n\ncontainer = None\n\nif payload is None:\n    container = {}\nelse:\n    # If payload is a list-like root, take the first element as container.\n    if isinstance(payload, list):\n        container = payload[0] if payload else {}\n    else:\n        try:\n            first = payload[0]\n            if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n                container = first\n            else:\n                container = payload\n        except Exception:\n            container = payload\n\nresults_raw = get_results(container) if container is not None else None\nresults = to_list(results_raw)\n\nreturn [{'json': {'products': results}}]"
      },
      "id": "m-prepare-products-after-a",
      "name": "Prepare Products After WF_A (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -60,
        -120
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-trigger-pt-after-a",
      "name": "Merge Trigger + Product Types After WF_A",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        150,
        -220
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-rebuild-input",
      "name": "Merge Rebuild Plan Input",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        340,
        -140
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from collections import defaultdict\n\nfirst_item = _input.first()\npayload = first_item.json if first_item else None\n\ndef read_key(container, key, default=None):\n    try:\n        value = container.get(key)\n        return default if value is None else value\n    except Exception:\n        try:\n            value = container[key]\n            return default if value is None else value\n        except Exception:\n            return default\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\ndef to_container(value):\n    if value is None:\n        return {}\n    if isinstance(value, list):\n        return value[0] if value else {}\n    try:\n        first = value[0]\n        if hasattr(first, 'get') or hasattr(first, '__getitem__'):\n            return first\n    except Exception:\n        pass\n    return value\n\ndef is_mapping_like(value):\n    return hasattr(value, 'get') or hasattr(value, '__getitem__')\n\nincoming = to_container(payload)\ntrigger_input = to_container(read_key(incoming, 'trigger', {}))\n\ntrigger_product_type_id = read_key(trigger_input, 'product_type_id')\ntrigger_domain = read_key(trigger_input, 'domain')\n\ntry:\n    trigger_product_type_id = int(trigger_product_type_id) if trigger_product_type_id is not None else None\nexcept Exception:\n    trigger_product_type_id = None\n\nproducts = to_list(read_key(incoming, 'products', []))\nproduct_types = to_list(read_key(incoming, 'product_types', []))\n\ndef as_tag_set(raw_tags):\n    if isinstance(raw_tags, list):\n        return set(str(t) for t in raw_tags)\n    if raw_tags is None:\n        return set()\n    try:\n        return set(str(t) for t in raw_tags)\n    except Exception:\n        return {str(raw_tags)}\n\npt_by_id = {}\nfor pt in product_types:\n    if not is_mapping_like(pt):\n        continue\n    pt_id = read_key(pt, 'id')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    pt_by_id[pt_id] = pt\n\nproducts_by_pt = defaultdict(list)\nfor p in products:\n    if not is_mapping_like(p):\n        continue\n    pt_id = read_key(p, 'prod_type')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    products_by_pt[pt_id].append(p)\n    if pt_id not in pt_by_id:\n        pt_by_id[pt_id] = {'id': pt_id, 'name': f'PT #{pt_id}', 'tags': []}\n\nall_pt_ids = sorted(pt_by_id.keys())\nif trigger_product_type_id is not None:\n    all_pt_ids = [pt_id for pt_id in all_pt_ids if pt_id == trigger_product_type_id]\n\nqueue_wf_a_subdomains_pt = []\nqueue_wf_b_nmap_product = []\nqueue_wf_c_targets_for_pt = []\nqueue_wf_d_pt_acunetixscan = []\n\nfor pt_id in all_pt_ids:\n    pt = pt_by_id.get(pt_id) or {}\n    pt_tags = as_tag_set(read_key(pt, 'tags', []))\n    pt_products = products_by_pt.get(pt_id, [])\n\n    normalized_products = []\n    for p in sorted(pt_products, key=lambda x: int(read_key(x, 'id', 0) or 0)):\n        product_id = read_key(p, 'id')\n        try:\n            product_id = int(product_id)\n        except Exception:\n            continue\n\n        tags = as_tag_set(read_key(p, 'tags', []))\n        needs_nmap = 'needs:nmap' in tags\n        nmap_done = ('nmap:done' in tags) or ('nmap:completed' in tags)\n        targets_ready = 'targets:ready' in tags\n        active_scan = 'acunetix:active' in tags\n\n        norm = {\n            'product_id': product_id,\n            'product_name': read_key(p, 'name'),\n            'product_type_id': pt_id,\n            'needs_nmap': needs_nmap,\n            'nmap_done': nmap_done,\n            'targets_ready': targets_ready,\n            'active_scan': active_scan,\n        }\n        normalized_products.append(norm)\n\n        if needs_nmap and not nmap_done:\n            queue_wf_b_nmap_product.append({\n                'product_id': product_id,\n                'product_name': read_key(p, 'name'),\n                'product_type_id': pt_id,\n                'domain': trigger_domain,\n            })\n\n    if len(normalized_products) == 0:\n        queue_wf_a_subdomains_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': read_key(pt, 'name'),\n            'domain': trigger_domain,\n        })\n        continue\n\n    needs_nmap_products = [p for p in normalized_products if p['needs_nmap']]\n    has_needs_nmap = len(needs_nmap_products) > 0\n    nmap_completed_for_all_needed = all(p['nmap_done'] for p in needs_nmap_products)\n    product_targets_ready_tag = any(p['targets_ready'] for p in normalized_products)\n\n    # Rule: enqueue PT for Targets only when there are Products with needs:nmap and all of them are nmap-done,\n    # or when an explicit readiness tag exists on Product (targets:ready).\n    if (has_needs_nmap and nmap_completed_for_all_needed) or product_targets_ready_tag:\n        queue_wf_c_targets_for_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': read_key(pt, 'name'),\n            'domain': trigger_domain,\n        })\n\n    pt_targets_ready = ('targets:ready' in pt_tags) or any(p['targets_ready'] for p in normalized_products)\n    pt_has_active_scan = ('acunetix:active' in pt_tags) or any(p['active_scan'] for p in normalized_products)\n\n    if pt_targets_ready and not pt_has_active_scan:\n        queue_wf_d_pt_acunetixscan.append({\n            'product_type_id': pt_id,\n            'product_type_name': read_key(pt, 'name'),\n            'domain': trigger_domain,\n        })\n\nreturn [{\n    'json': {\n        'run_subdomains': len(queue_wf_a_subdomains_pt) > 0,\n        'run_nmap': len(queue_wf_b_nmap_product) > 0,\n        'run_targets': len(queue_wf_c_targets_for_pt) > 0,\n        'run_acunetix': len(queue_wf_d_pt_acunetixscan) > 0,\n        'queue_wf_a_subdomains_pt': queue_wf_a_subdomains_pt,\n        'queue_wf_b_nmap_product': queue_wf_b_nmap_product,\n        'queue_wf_c_targets_for_pt': queue_wf_c_targets_for_pt,\n        'queue_wf_d_pt_acunetixscan': queue_wf_d_pt_acunetixscan,\n        'products_grouped_by_prod_type': {str(k): v for k, v in products_by_pt.items()},\n        'trigger_product_type_id': trigger_product_type_id,\n        'trigger_domain': trigger_domain,\n    }\n}]"
      },
      "id": "m-rebuild-plan",
      "name": "Rebuild Plan After WF_A (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        -140
      ]
    }
  ],
  "connections": {
    "Trigger": {
      "main": [
        [
          {
            "node": "Get Product Types",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Trigger Input (Python)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Products",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Products": {
      "main": [
        [
          {
            "node": "Prepare Products (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Plan (Python)": {
      "main": [
        [
          {
            "node": "Need WF_A_Subdomains_PT?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_A_Subdomains_PT?": {
      "main": [
        [
          {
            "node": "Expand WF_A Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Need WF_B_Nmap_Product?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run WF_A_Subdomains_PT": {
      "main": [
        [
          {
            "node": "Get Product Types After WF_A",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Products After WF_A",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_B_Nmap_Product?": {
      "main": [
        [
          {
            "node": "Expand WF_B Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Need WF_C_Targets_For_PT?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run WF_B_Nmap_Product": {
      "main": [
        [
          {
            "node": "Need WF_C_Targets_For_PT?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_C_Targets_For_PT?": {
      "main": [
        [
          {
            "node": "Expand WF_C Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Need WF_D_PT_AcunetixScan?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run WF_C_Targets_For_PT": {
      "main": [
        [
          {
            "node": "Need WF_D_PT_AcunetixScan?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_D_PT_AcunetixScan?": {
      "main": [
        [
          {
            "node": "Expand WF_D Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Get Product Types": {
      "main": [
        [
          {
            "node": "Prepare Product Types (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_A Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_A_Subdomains_PT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_B Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_B_Nmap_Product",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_C Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_C_Targets_For_PT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_D Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_D_PT_AcunetixScan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Product Types (Python)": {
      "main": [
        [
          {
            "node": "Merge Trigger + Product Types",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Prepare Trigger Input (Python)": {
      "main": [
        [
          {
            "node": "Merge Trigger + Product Types",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Products (Python)": {
      "main": [
        [
          {
            "node": "Merge Build Plan Input",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Trigger + Product Types": {
      "main": [
        [
          {
            "node": "Merge Build Plan Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Trigger + Product Types After WF_A",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Build Plan Input": {
      "main": [
        [
          {
            "node": "Build Plan (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Product Types After WF_A": {
      "main": [
        [
          {
            "node": "Prepare Product Types After WF_A (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Products After WF_A": {
      "main": [
        [
          {
            "node": "Prepare Products After WF_A (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Product Types After WF_A (Python)": {
      "main": [
        [
          {
            "node": "Merge Trigger + Product Types After WF_A",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Prepare Products After WF_A (Python)": {
      "main": [
        [
          {
            "node": "Merge Rebuild Plan Input",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Trigger + Product Types After WF_A": {
      "main": [
        [
          {
            "node": "Merge Rebuild Plan Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Rebuild Plan Input": {
      "main": [
        [
          {
            "node": "Rebuild Plan After WF_A (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rebuild Plan After WF_A (Python)": {
      "main": [
        [
          {
            "node": "Need WF_B_Nmap_Product?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": []
}
