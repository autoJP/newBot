{
  "name": "WF_Dojo_Master",
  "nodes": [
    {
      "parameters": {},
      "id": "m-trigger",
      "name": "Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        -1400,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/product_types/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-product-types",
      "name": "Get Product Types",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1360,
        100
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-products",
      "name": "Get Products",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -1180,
        100
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from collections import defaultdict\n\nfirst_item = _input.first()\nincoming = first_item.json if first_item else {}\nif not isinstance(incoming, dict):\n    incoming = {}\n\ntrigger_input = incoming.get('trigger') or {}\nif not isinstance(trigger_input, dict):\n    trigger_input = {}\n\ntrigger_product_type_id = trigger_input.get('product_type_id')\ntrigger_domain = trigger_input.get('domain')\n\ntry:\n    trigger_product_type_id = int(trigger_product_type_id) if trigger_product_type_id is not None else None\nexcept Exception:\n    trigger_product_type_id = None\n\nproducts = incoming.get('products') or []\nproduct_types = incoming.get('product_types') or []\n\nif not isinstance(products, list):\n    products = []\nif not isinstance(product_types, list):\n    product_types = []\n\ndef as_tag_set(raw_tags):\n    if isinstance(raw_tags, list):\n        return set(str(t) for t in raw_tags)\n    if raw_tags is None:\n        return set()\n    return {str(raw_tags)}\n\npt_by_id = {}\nfor pt in product_types:\n    if not isinstance(pt, dict):\n        continue\n    pt_id = pt.get('id')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    pt_by_id[pt_id] = pt\n\nproducts_by_pt = defaultdict(list)\nfor p in products:\n    if not isinstance(p, dict):\n        continue\n    pt_id = p.get('prod_type')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    products_by_pt[pt_id].append(p)\n    if pt_id not in pt_by_id:\n        pt_by_id[pt_id] = {'id': pt_id, 'name': f'PT #{pt_id}', 'tags': []}\n\nall_pt_ids = sorted(pt_by_id.keys())\nif trigger_product_type_id is not None:\n    all_pt_ids = [pt_id for pt_id in all_pt_ids if pt_id == trigger_product_type_id]\n\nqueue_wf_a_subdomains_pt = []\nqueue_wf_b_nmap_product = []\nqueue_wf_c_targets_for_pt = []\nqueue_wf_d_pt_acunetixscan = []\n\nfor pt_id in all_pt_ids:\n    pt = pt_by_id.get(pt_id) or {}\n    pt_tags = as_tag_set(pt.get('tags'))\n    pt_products = products_by_pt.get(pt_id, [])\n\n    normalized_products = []\n    for p in sorted(pt_products, key=lambda x: int(x.get('id') or 0)):\n        product_id = p.get('id')\n        try:\n            product_id = int(product_id)\n        except Exception:\n            continue\n\n        tags = as_tag_set(p.get('tags'))\n        needs_nmap = 'needs:nmap' in tags\n        nmap_done = ('nmap:done' in tags) or ('nmap:completed' in tags)\n        targets_ready = 'targets:ready' in tags\n        active_scan = 'acunetix:active' in tags\n\n        norm = {\n            'product_id': product_id,\n            'product_name': p.get('name'),\n            'product_type_id': pt_id,\n            'needs_nmap': needs_nmap,\n            'nmap_done': nmap_done,\n            'targets_ready': targets_ready,\n            'active_scan': active_scan,\n        }\n        normalized_products.append(norm)\n\n        if needs_nmap and not nmap_done:\n            queue_wf_b_nmap_product.append({\n                'product_id': product_id,\n                'product_name': p.get('name'),\n                'product_type_id': pt_id,\n                'domain': trigger_domain,\n            })\n\n    if len(normalized_products) == 0:\n        queue_wf_a_subdomains_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': pt.get('name'),\n            'domain': trigger_domain,\n        })\n        continue\n\n    needs_nmap_products = [p for p in normalized_products if p['needs_nmap']]\n    has_needs_nmap = len(needs_nmap_products) > 0\n    nmap_completed_for_all_needed = all(p['nmap_done'] for p in needs_nmap_products)\n    product_targets_ready_tag = any(p['targets_ready'] for p in normalized_products)\n\n    # Rule: enqueue PT for Targets only when there are Products with needs:nmap and all of them are nmap-done,\n    # or when an explicit readiness tag exists on Product (targets:ready).\n    if (has_needs_nmap and nmap_completed_for_all_needed) or product_targets_ready_tag:\n        queue_wf_c_targets_for_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': pt.get('name'),\n            'domain': trigger_domain,\n        })\n\n    pt_targets_ready = ('targets:ready' in pt_tags) or any(p['targets_ready'] for p in normalized_products)\n    pt_has_active_scan = ('acunetix:active' in pt_tags) or any(p['active_scan'] for p in normalized_products)\n\n    if pt_targets_ready and not pt_has_active_scan:\n        queue_wf_d_pt_acunetixscan.append({\n            'product_type_id': pt_id,\n            'product_type_name': pt.get('name'),\n            'domain': trigger_domain,\n        })\n\nreturn [{\n    'json': {\n        'run_subdomains': len(queue_wf_a_subdomains_pt) > 0,\n        'run_nmap': len(queue_wf_b_nmap_product) > 0,\n        'run_targets': len(queue_wf_c_targets_for_pt) > 0,\n        'run_acunetix': len(queue_wf_d_pt_acunetixscan) > 0,\n        'queue_wf_a_subdomains_pt': queue_wf_a_subdomains_pt,\n        'queue_wf_b_nmap_product': queue_wf_b_nmap_product,\n        'queue_wf_c_targets_for_pt': queue_wf_c_targets_for_pt,\n        'queue_wf_d_pt_acunetixscan': queue_wf_d_pt_acunetixscan,\n        'products_grouped_by_prod_type': {str(k): v for k, v in products_by_pt.items()},\n        'trigger_product_type_id': trigger_product_type_id,\n        'trigger_domain': trigger_domain,\n    }\n}]"
      },
      "id": "m-plan",
      "name": "Build Plan (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -950,
        100
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.run_subdomains }}"
            }
          ]
        }
      },
      "id": "m-if-subdomains",
      "name": "Need WF_A_Subdomains_PT?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -760,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_A_Subdomains_PT",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-a",
      "name": "Run WF_A_Subdomains_PT",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        -460,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.run_nmap }}"
            }
          ]
        }
      },
      "id": "m-if-nmap",
      "name": "Need WF_B_Nmap_Product?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -340,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_B_Nmap_Product",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-b",
      "name": "Run WF_B_Nmap_Product",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        -40,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.run_targets }}"
            }
          ]
        }
      },
      "id": "m-if-targets",
      "name": "Need WF_C_Targets_For_PT?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        60,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_C_Targets_For_PT",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-c",
      "name": "Run WF_C_Targets_For_PT",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        360,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.run_acunetix }}"
            }
          ]
        }
      },
      "id": "m-if-acu",
      "name": "Need WF_D_PT_AcunetixScan?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        460,
        100
      ]
    },
    {
      "parameters": {
        "workflowId": "WF_D_PT_AcunetixScan",
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "m-run-d",
      "name": "Run WF_D_PT_AcunetixScan",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        670,
        20
      ],
      "continueOnFail": false
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nincoming = first_item.json if first_item else {}\nif not isinstance(incoming, dict):\n    incoming = {}\nout = []\nfor row in incoming.get('queue_wf_a_subdomains_pt', []) or []:\n    if not isinstance(row, dict):\n        continue\n    item = {}\n    item['product_type_id'] = row.get('product_type_id')\n    item['product_type_name'] = row.get('product_type_name')\n    item['domain'] = row.get('domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-a",
      "name": "Expand WF_A Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -660,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nincoming = first_item.json if first_item else {}\nif not isinstance(incoming, dict):\n    incoming = {}\nout = []\nfor row in incoming.get('queue_wf_b_nmap_product', []) or []:\n    if not isinstance(row, dict):\n        continue\n    item = {}\n    item['product_id'] = row.get('product_id')\n    item['product_name'] = row.get('product_name')\n    item['product_type_id'] = row.get('product_type_id')\n    item['domain'] = row.get('domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-b",
      "name": "Expand WF_B Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nincoming = first_item.json if first_item else {}\nif not isinstance(incoming, dict):\n    incoming = {}\nout = []\nfor row in incoming.get('queue_wf_c_targets_for_pt', []) or []:\n    if not isinstance(row, dict):\n        continue\n    item = {}\n    item['product_type_id'] = row.get('product_type_id')\n    item['product_type_name'] = row.get('product_type_name')\n    item['domain'] = row.get('domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-c",
      "name": "Expand WF_C Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        160,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nincoming = first_item.json if first_item else {}\nif not isinstance(incoming, dict):\n    incoming = {}\nout = []\nfor row in incoming.get('queue_wf_d_pt_acunetixscan', []) or []:\n    if not isinstance(row, dict):\n        continue\n    item = {}\n    item['product_type_id'] = row.get('product_type_id')\n    item['product_type_name'] = row.get('product_type_name')\n    item['domain'] = row.get('domain')\n    out.append({'json': item})\nreturn out"
      },
      "id": "m-expand-d",
      "name": "Expand WF_D Candidates (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        20
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nitem = first_item.json if first_item else {}\nif not isinstance(item, dict):\n    item = {}\nreturn [{'json': {'trigger': item}}]"
      },
      "id": "m-prepare-trigger",
      "name": "Prepare Trigger Input (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1170,
        -80
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nitem = first_item.json if first_item else {}\n\n# n8n Python runtime can expose item.json as a proxy object (not a plain dict),\n# so avoid strict isinstance(dict) checks here.\ncandidate = None\ntry:\n    candidate = item.get('results')\nexcept Exception:\n    try:\n        candidate = item['results']\n    except Exception:\n        candidate = None\n\nresults = candidate if isinstance(candidate, list) else []\nreturn [{'json': {'product_types': results}}]"
      },
      "id": "m-prepare-pt",
      "name": "Prepare Product Types (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -960,
        -80
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nitem = first_item.json if first_item else {}\nif not isinstance(item, dict):\n    item = {}\nresults = item.get('results')\nif not isinstance(results, list):\n    results = []\nreturn [{'json': {'products': results}}]"
      },
      "id": "m-prepare-products",
      "name": "Prepare Products (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -740,
        280
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-trigger-pt",
      "name": "Merge Trigger + Product Types",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -740,
        -80
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-build-input",
      "name": "Merge Build Plan Input",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        -520,
        100
      ]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/product_types/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-product-types-after-a",
      "name": "Get Product Types After WF_A",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -300,
        -260
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/?limit=1000' }}",
        "options": {}
      },
      "id": "m-get-products-after-a",
      "name": "Get Products After WF_A",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -300,
        -120
      ],
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nitem = first_item.json if first_item else {}\nif not isinstance(item, dict):\n    item = {}\nresults = item.get('results')\nif not isinstance(results, list):\n    results = []\nreturn [{'json': {'product_types': results}}]"
      },
      "id": "m-prepare-pt-after-a",
      "name": "Prepare Product Types After WF_A (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -60,
        -260
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "first_item = _input.first()\nitem = first_item.json if first_item else {}\nif not isinstance(item, dict):\n    item = {}\nresults = item.get('results')\nif not isinstance(results, list):\n    results = []\nreturn [{'json': {'products': results}}]"
      },
      "id": "m-prepare-products-after-a",
      "name": "Prepare Products After WF_A (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -60,
        -120
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-trigger-pt-after-a",
      "name": "Merge Trigger + Product Types After WF_A",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        150,
        -220
      ]
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "id": "m-merge-rebuild-input",
      "name": "Merge Rebuild Plan Input",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [
        340,
        -140
      ]
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from collections import defaultdict\n\nfirst_item = _input.first()\nincoming = first_item.json if first_item else {}\nif not isinstance(incoming, dict):\n    incoming = {}\n\ntrigger_input = incoming.get('trigger') or {}\nif not isinstance(trigger_input, dict):\n    trigger_input = {}\n\ntrigger_product_type_id = trigger_input.get('product_type_id')\ntrigger_domain = trigger_input.get('domain')\n\ntry:\n    trigger_product_type_id = int(trigger_product_type_id) if trigger_product_type_id is not None else None\nexcept Exception:\n    trigger_product_type_id = None\n\nproducts = incoming.get('products') or []\nproduct_types = incoming.get('product_types') or []\n\nif not isinstance(products, list):\n    products = []\nif not isinstance(product_types, list):\n    product_types = []\n\ndef as_tag_set(raw_tags):\n    if isinstance(raw_tags, list):\n        return set(str(t) for t in raw_tags)\n    if raw_tags is None:\n        return set()\n    return {str(raw_tags)}\n\npt_by_id = {}\nfor pt in product_types:\n    if not isinstance(pt, dict):\n        continue\n    pt_id = pt.get('id')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    pt_by_id[pt_id] = pt\n\nproducts_by_pt = defaultdict(list)\nfor p in products:\n    if not isinstance(p, dict):\n        continue\n    pt_id = p.get('prod_type')\n    try:\n        pt_id = int(pt_id)\n    except Exception:\n        continue\n    products_by_pt[pt_id].append(p)\n    if pt_id not in pt_by_id:\n        pt_by_id[pt_id] = {'id': pt_id, 'name': f'PT #{pt_id}', 'tags': []}\n\nall_pt_ids = sorted(pt_by_id.keys())\nif trigger_product_type_id is not None:\n    all_pt_ids = [pt_id for pt_id in all_pt_ids if pt_id == trigger_product_type_id]\n\nqueue_wf_a_subdomains_pt = []\nqueue_wf_b_nmap_product = []\nqueue_wf_c_targets_for_pt = []\nqueue_wf_d_pt_acunetixscan = []\n\nfor pt_id in all_pt_ids:\n    pt = pt_by_id.get(pt_id) or {}\n    pt_tags = as_tag_set(pt.get('tags'))\n    pt_products = products_by_pt.get(pt_id, [])\n\n    normalized_products = []\n    for p in sorted(pt_products, key=lambda x: int(x.get('id') or 0)):\n        product_id = p.get('id')\n        try:\n            product_id = int(product_id)\n        except Exception:\n            continue\n\n        tags = as_tag_set(p.get('tags'))\n        needs_nmap = 'needs:nmap' in tags\n        nmap_done = ('nmap:done' in tags) or ('nmap:completed' in tags)\n        targets_ready = 'targets:ready' in tags\n        active_scan = 'acunetix:active' in tags\n\n        norm = {\n            'product_id': product_id,\n            'product_name': p.get('name'),\n            'product_type_id': pt_id,\n            'needs_nmap': needs_nmap,\n            'nmap_done': nmap_done,\n            'targets_ready': targets_ready,\n            'active_scan': active_scan,\n        }\n        normalized_products.append(norm)\n\n        if needs_nmap and not nmap_done:\n            queue_wf_b_nmap_product.append({\n                'product_id': product_id,\n                'product_name': p.get('name'),\n                'product_type_id': pt_id,\n                'domain': trigger_domain,\n            })\n\n    if len(normalized_products) == 0:\n        queue_wf_a_subdomains_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': pt.get('name'),\n            'domain': trigger_domain,\n        })\n        continue\n\n    needs_nmap_products = [p for p in normalized_products if p['needs_nmap']]\n    has_needs_nmap = len(needs_nmap_products) > 0\n    nmap_completed_for_all_needed = all(p['nmap_done'] for p in needs_nmap_products)\n    product_targets_ready_tag = any(p['targets_ready'] for p in normalized_products)\n\n    # Rule: enqueue PT for Targets only when there are Products with needs:nmap and all of them are nmap-done,\n    # or when an explicit readiness tag exists on Product (targets:ready).\n    if (has_needs_nmap and nmap_completed_for_all_needed) or product_targets_ready_tag:\n        queue_wf_c_targets_for_pt.append({\n            'product_type_id': pt_id,\n            'product_type_name': pt.get('name'),\n            'domain': trigger_domain,\n        })\n\n    pt_targets_ready = ('targets:ready' in pt_tags) or any(p['targets_ready'] for p in normalized_products)\n    pt_has_active_scan = ('acunetix:active' in pt_tags) or any(p['active_scan'] for p in normalized_products)\n\n    if pt_targets_ready and not pt_has_active_scan:\n        queue_wf_d_pt_acunetixscan.append({\n            'product_type_id': pt_id,\n            'product_type_name': pt.get('name'),\n            'domain': trigger_domain,\n        })\n\nreturn [{\n    'json': {\n        'run_subdomains': len(queue_wf_a_subdomains_pt) > 0,\n        'run_nmap': len(queue_wf_b_nmap_product) > 0,\n        'run_targets': len(queue_wf_c_targets_for_pt) > 0,\n        'run_acunetix': len(queue_wf_d_pt_acunetixscan) > 0,\n        'queue_wf_a_subdomains_pt': queue_wf_a_subdomains_pt,\n        'queue_wf_b_nmap_product': queue_wf_b_nmap_product,\n        'queue_wf_c_targets_for_pt': queue_wf_c_targets_for_pt,\n        'queue_wf_d_pt_acunetixscan': queue_wf_d_pt_acunetixscan,\n        'products_grouped_by_prod_type': {str(k): v for k, v in products_by_pt.items()},\n        'trigger_product_type_id': trigger_product_type_id,\n        'trigger_domain': trigger_domain,\n    }\n}]"
      },
      "id": "m-rebuild-plan",
      "name": "Rebuild Plan After WF_A (Python)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        -140
      ]
    }
  ],
  "connections": {
    "Trigger": {
      "main": [
        [
          {
            "node": "Get Product Types",
            "type": "main",
            "index": 0
          },
          {
            "node": "Prepare Trigger Input (Python)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Products",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Products": {
      "main": [
        [
          {
            "node": "Prepare Products (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Plan (Python)": {
      "main": [
        [
          {
            "node": "Need WF_A_Subdomains_PT?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_A_Subdomains_PT?": {
      "main": [
        [
          {
            "node": "Expand WF_A Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Need WF_B_Nmap_Product?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run WF_A_Subdomains_PT": {
      "main": [
        [
          {
            "node": "Get Product Types After WF_A",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Products After WF_A",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_B_Nmap_Product?": {
      "main": [
        [
          {
            "node": "Expand WF_B Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Need WF_C_Targets_For_PT?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run WF_B_Nmap_Product": {
      "main": [
        [
          {
            "node": "Need WF_C_Targets_For_PT?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_C_Targets_For_PT?": {
      "main": [
        [
          {
            "node": "Expand WF_C Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Need WF_D_PT_AcunetixScan?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run WF_C_Targets_For_PT": {
      "main": [
        [
          {
            "node": "Need WF_D_PT_AcunetixScan?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Need WF_D_PT_AcunetixScan?": {
      "main": [
        [
          {
            "node": "Expand WF_D Candidates (Python)",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Get Product Types": {
      "main": [
        [
          {
            "node": "Prepare Product Types (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_A Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_A_Subdomains_PT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_B Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_B_Nmap_Product",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_C Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_C_Targets_For_PT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Expand WF_D Candidates (Python)": {
      "main": [
        [
          {
            "node": "Run WF_D_PT_AcunetixScan",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Product Types (Python)": {
      "main": [
        [
          {
            "node": "Merge Trigger + Product Types",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Prepare Trigger Input (Python)": {
      "main": [
        [
          {
            "node": "Merge Trigger + Product Types",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Products (Python)": {
      "main": [
        [
          {
            "node": "Merge Build Plan Input",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Trigger + Product Types": {
      "main": [
        [
          {
            "node": "Merge Build Plan Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Trigger + Product Types After WF_A",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Build Plan Input": {
      "main": [
        [
          {
            "node": "Build Plan (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Product Types After WF_A": {
      "main": [
        [
          {
            "node": "Prepare Product Types After WF_A (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Products After WF_A": {
      "main": [
        [
          {
            "node": "Prepare Products After WF_A (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Product Types After WF_A (Python)": {
      "main": [
        [
          {
            "node": "Merge Trigger + Product Types After WF_A",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Prepare Products After WF_A (Python)": {
      "main": [
        [
          {
            "node": "Merge Rebuild Plan Input",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Trigger + Product Types After WF_A": {
      "main": [
        [
          {
            "node": "Merge Rebuild Plan Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Rebuild Plan Input": {
      "main": [
        [
          {
            "node": "Rebuild Plan After WF_A (Python)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rebuild Plan After WF_A (Python)": {
      "main": [
        [
          {
            "node": "Need WF_B_Nmap_Product?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": []
}
