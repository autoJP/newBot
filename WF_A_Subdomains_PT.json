{
  "name": "WF_A_Subdomains_PT",
  "nodes": [
    {
      "parameters": {},
      "name": "Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        -1200,
        112
      ],
      "id": "96413fd4-3415-4449-aa55-669b63ed1fbe"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "product_type_id",
              "value": "={{ $json.product_type_id }}"
            },
            {
              "name": "domain",
              "value": "={{ $json.domain || '' }}"
            }
          ]
        },
        "options": {}
      },
      "name": "Set Parameters",
      "type": "n8n-nodes-base.set",
      "typeVersion": 1,
      "position": [
        -1008,
        112
      ],
      "id": "08561f93-0a20-4956-a2e1-9f2b27a71f54"
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/product_types/' + $json.product_type_id + '/' }}",
        "options": {}
      },
      "name": "Get Product Type from Dojo",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        -800,
        112
      ],
      "id": "00ccc811-2c6f-4a27-a2b4-34955a5a68d9",
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import re\n\n\ndef is_mapping_like(v):\n    return hasattr(v, 'get') or hasattr(v, '__getitem__')\n\n\ndef read_key(container, key, default=None):\n    try:\n        val = container.get(key)\n        return default if val is None else val\n    except Exception:\n        try:\n            val = container[key]\n            return default if val is None else val\n        except Exception:\n            return default\n\n\ndef to_candidates(payload):\n    # Case 1: mapping-like single object\n    if is_mapping_like(payload):\n        return [payload]\n\n    # Case 2: list/iterable of objects (including n8n proxy arrays)\n    try:\n        arr = [x for x in payload]\n    except Exception:\n        return []\n\n    out = []\n    for x in arr:\n        if is_mapping_like(x):\n            out.append(x)\n    return out\n\n\nitems = _input.all()\nif not items:\n    raise Exception('Extract Domain: no input items')\n\noutput = []\nfor item in items:\n    payload = item.json\n    candidates = to_candidates(payload)\n\n    for pt in candidates:\n        # Prefer `id` from Dojo Product Type input; fallback to product_type_id\n        pt_id_raw = read_key(pt, 'id')\n        if pt_id_raw is None:\n            pt_id_raw = read_key(pt, 'product_type_id')\n\n        try:\n            pt_id = int(pt_id_raw)\n        except Exception:\n            raise Exception(f'product_type_id is missing or invalid: {pt_id_raw}')\n\n        domain = (read_key(pt, 'name', '') or read_key(pt, 'domain', '')).strip()\n        if not domain:\n            raise Exception(f'Could not determine domain for Product Type {pt_id}')\n\n        domain = re.sub(r'^https?://', '', domain, flags=re.IGNORECASE)\n        domain = domain.split('/')[0]\n        domain = domain.split(':')[0]\n        domain = domain.lower().strip()\n\n        if not domain:\n            raise Exception(f'Domain normalization produced empty value for Product Type {pt_id}')\n\n        output.append({\n            'json': {\n                'product_type_id': pt_id,\n                'domain': domain,\n                'product_type': pt,\n            }\n        })\n\nif not output:\n    raise Exception('Extract Domain: no valid product type objects in input')\n\nreturn output\n"
      },
      "name": "Extract Domain",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        112
      ],
      "id": "7a05258d-d662-4fca-b658-94d5f1ce79b3"
    },
    {
      "parameters": {
        "command": "=python3 /opt/tools/enum_subs_auto.py \\\n  --domain \"{{ $json.domain }}\" \\\n  --resolve \\\n  --json-output"
      },
      "name": "Run Subdomain Enumeration",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        -400,
        112
      ],
      "id": "a08c5604-cacd-4be3-9460-0f02a9f2899d"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.exitCode }}",
              "operation": "equal"
            }
          ]
        }
      },
      "name": "Check Script Success",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -208,
        112
      ],
      "id": "86915ca7-6b2b-4940-a565-7aaaec449978"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import json\n\n\ndef read_key(container, key, default=None):\n    try:\n        val = container.get(key)\n        return default if val is None else val\n    except Exception:\n        try:\n            val = container[key]\n            return default if val is None else val\n        except Exception:\n            return default\n\n\nitems = _input.all()\nextract_items = _(\"Extract Domain\").all()\n\nif not items:\n    raise Exception('Parse Results: no input items')\n\noutput = []\nfor idx, item in enumerate(items):\n    payload = item.json\n\n    stdout = read_key(payload, 'stdout', '{}')\n    try:\n        result = json.loads(stdout)\n    except Exception as e:\n        raise Exception(f'Failed to parse JSON from enum_subs_auto.py: {e}')\n\n    subs = read_key(result, 'subs', [])\n    if not isinstance(subs, list):\n        raise Exception('Invalid subdomains format from script')\n\n    hosts = []\n    for sub in subs:\n        if isinstance(sub, str) and sub:\n            hosts.append(sub)\n        elif isinstance(sub, dict) and isinstance(sub.get('host'), str) and sub.get('host'):\n            hosts.append(sub['host'])\n\n    extract = extract_items[idx].json if idx < len(extract_items) else {}\n\n    output.append({\n        'json': {\n            'product_type_id': read_key(extract, 'product_type_id'),\n            'domain': read_key(extract, 'domain'),\n            'subdomains': hosts,\n            'raw_result': result,\n            'product_type': read_key(extract, 'product_type'),\n            'workflow_status': 'ok',\n            'error_message': None,\n        }\n    })\n\nreturn output\n"
      },
      "name": "Parse Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "id": "418e08e4-0e2d-44b7-b993-1bafabc98ec2"
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/?prod_type=' + $json.product_type_id + '&limit=200&offset=0' }}",
        "options": {}
      },
      "name": "Get Existing Products",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        208,
        0
      ],
      "id": "a6360916-2e6e-4d0b-b385-a1dcc0154c97",
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import os\nimport json\nimport urllib.request\n\ndef read_key(container, key, default=None):\n    try:\n        val = container.get(key)\n        return default if val is None else val\n    except Exception:\n        try:\n            val = container[key]\n            return default if val is None else val\n        except Exception:\n            return default\n\n\ndef to_list(value):\n    if value is None:\n        return []\n    if isinstance(value, list):\n        return value\n    try:\n        return [v for v in value]\n    except Exception:\n        return []\n\n\ndef fetch_next_pages(next_url):\n    token = (os.environ.get('DOJO_API_TOKEN') or '').strip()\n    if not next_url or not token:\n        return []\n\n    out = []\n    visited = set()\n    current = str(next_url)\n\n    while current and current not in visited:\n        visited.add(current)\n        req = urllib.request.Request(current)\n        req.add_header('Authorization', f'Token {token}')\n        req.add_header('Accept', 'application/json')\n        with urllib.request.urlopen(req, timeout=30) as resp:\n            payload = json.loads(resp.read().decode('utf-8') or '{}')\n        out.extend(to_list(read_key(payload, 'results', [])))\n        current = read_key(payload, 'next')\n\n    return out\n\n\nitems = _input.all()\nparsed_items = _(\"Parse Results\").all()\nextract_items = _(\"Extract Domain\").all()\n\nif not items:\n    return []\n\nparsed_json = [it.json for it in parsed_items]\nextract_json = [it.json for it in extract_items]\n\nexisting_names = set()\nnext_url = None\nfor idx, item in enumerate(items):\n    payload = item.json if item and isinstance(item.json, dict) else {}\n    for product in to_list(read_key(payload, 'results', [])):\n        name = read_key(product, 'name')\n        if isinstance(name, str) and name:\n            existing_names.add(name)\n    if next_url is None:\n        next_url = read_key(payload, 'next')\n\nfor product in fetch_next_pages(next_url):\n    name = read_key(product, 'name')\n    if isinstance(name, str) and name:\n        existing_names.add(name)\n\noutput = []\nfor idx, parsed in enumerate(parsed_json or [{}]):\n    parsed = parsed if isinstance(parsed, dict) else {}\n    extract = extract_json[idx] if idx < len(extract_json) else (extract_json[0] if extract_json else {})\n\n    pt_id = read_key(parsed, 'product_type_id', read_key(extract, 'product_type_id'))\n    domain = read_key(parsed, 'domain', read_key(extract, 'domain'))\n\n    subs = to_list(read_key(parsed, 'subdomains', []))\n    if len(subs) == 0:\n        raw_result = read_key(parsed, 'raw_result', {})\n        raw_subs = to_list(read_key(raw_result, 'subs', []))\n        rebuilt = []\n        for s in raw_subs:\n            host = read_key(s, 'host') if s is not None else None\n            if isinstance(host, str) and host:\n                rebuilt.append(host)\n            elif isinstance(s, str) and s:\n                rebuilt.append(s)\n        subs = rebuilt\n\n    hosts_to_create = []\n    for host in subs:\n        if isinstance(host, str) and host and host not in existing_names:\n            hosts_to_create.append(host)\n\n    if len(hosts_to_create) == 0 and isinstance(domain, str) and domain and domain not in existing_names:\n        hosts_to_create.append(domain)\n\n    seen = set()\n    for host in hosts_to_create:\n        if host in seen:\n            continue\n        seen.add(host)\n        output.append({'json': {'product_type_id': pt_id, 'domain': domain, 'host': host}})\n\nreturn output"
      },
      "name": "Prepare Create List",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        0
      ],
      "id": "d7758be2-a147-46d3-b095-428d0648f08c"
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "requestMethod": "POST",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/products/' }}",
        "options": {
          "bodyContentType": "json"
        },
        "bodyParametersUi": {
          "parameter": [
            {
              "name": "name",
              "value": "={{ $json.host }}"
            },
            {
              "name": "prod_type",
              "value": "={{ $json.product_type_id }}"
            },
            {
              "name": "description",
              "value": "={{ 'Subdomain discovered for ' + $json[\"domain\"] + ' via automated enumeration' }}"
            },
            {
              "name": "tags",
              "value": "={{ ['needs:nmap'] }}"
            }
          ]
        }
      },
      "name": "Create Product in Dojo",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        608,
        0
      ],
      "id": "1c6289f8-cc3d-4f95-b390-6af4b9a9754d",
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "from datetime import datetime, timezone\n\n\ndef to_plain(value):\n    # 1) Native Python types\n    if value is None or isinstance(value, (str, int, float, bool)):\n        return value\n    if isinstance(value, list):\n        return [to_plain(v) for v in value]\n    if isinstance(value, dict):\n        return {k: to_plain(v) for k, v in value.items()}\n\n    # 2) PyProxy-like objects (n8n python sandbox)\n    try:\n        if hasattr(value, 'to_py'):\n            return to_plain(value.to_py())\n    except Exception:\n        pass\n\n    # 3) Mapping-like via keys\n    try:\n        keys = list(value.keys())\n        out = {}\n        for k in keys:\n            out[k] = to_plain(value[k])\n        return out\n    except Exception:\n        pass\n\n    # 4) Iterable list-like\n    try:\n        return [to_plain(v) for v in value]\n    except Exception:\n        pass\n\n    return value\n\n\ndef host_list_from_subs(subs):\n    out = []\n    for s in subs:\n        if isinstance(s, str) and s:\n            out.append(s)\n        elif isinstance(s, dict):\n            host = s.get('host')\n            if isinstance(host, str) and host:\n                out.append(host)\n    return out\n\n\nitems = _input.all()\nif not items:\n    return []\n\noutput = []\nfor item in items:\n    payload = to_plain(item.json)\n    if not isinstance(payload, dict):\n        payload = {}\n\n    product_type_id = payload.get('product_type_id')\n    domain = payload.get('domain')\n\n    subs = payload.get('subdomains')\n    if not isinstance(subs, list):\n        subs = []\n\n    # fallback: rebuild from raw_result.subs\n    if len(subs) == 0:\n        raw_result = payload.get('raw_result')\n        if isinstance(raw_result, dict):\n            raw_subs = raw_result.get('subs')\n            if isinstance(raw_subs, list):\n                subs = host_list_from_subs(raw_subs)\n\n    # normalize final host list to strings\n    final_hosts = host_list_from_subs(subs)\n\n    output.append({\n        'json': {\n            'product_type_id': product_type_id,\n            'domain': domain,\n            'total_subdomains_found': len(final_hosts),\n            'timestamp': datetime.now(timezone.utc).isoformat(),\n        }\n    })\n\nreturn output\n"
      },
      "name": "Generate Final Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        208
      ],
      "id": "c06f056f-3b53-4e4f-b7bc-b31b2e070d4f"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "item = _input.first()\npayload = item.json if item and isinstance(item.json, dict) else {}\nextract_item = _(\"Extract Domain\").first()\nextract = extract_item.json if extract_item and isinstance(extract_item.json, dict) else {}\n\nexit_code = payload.get('exitCode')\nstderr = payload.get('stderr') or ''\nstdout = payload.get('stdout') or ''\nerror_message = f'Subdomain enumeration failed with exit code {exit_code}: {stderr}'.strip()\n\nreturn [{\n    'json': {\n        'product_type_id': extract.get('product_type_id'),\n        'domain': extract.get('domain'),\n        'product_type': extract.get('product_type'),\n        'subdomains': [],\n        'raw_result': {'stdout': stdout, 'stderr': stderr, 'exit_code': exit_code},\n        'workflow_status': 'error',\n        'error_message': error_message,\n    }\n}]"
      },
      "name": "Handle Script Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        208
      ],
      "id": "c1357515-58a9-47b1-b598-3842a2aacd4e"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import json\nimport re\nfrom datetime import datetime, timezone\n\nBLOCK_START = \"PT_STATE_JSON_START\"\nBLOCK_END = \"PT_STATE_JSON_END\"\n\n\ndef read_key(container, key, default=None):\n    try:\n        val = container.get(key)\n        return default if val is None else val\n    except Exception:\n        try:\n            val = container[key]\n            return default if val is None else val\n        except Exception:\n            return default\n\n\ndef parse_state(description):\n    if not isinstance(description, str):\n        return {}\n    m = re.search(rf\"{BLOCK_START}\\n(.*?)\\n{BLOCK_END}\", description, re.DOTALL)\n    if not m:\n        return {}\n    try:\n        state = json.loads(m.group(1).strip())\n        return state if isinstance(state, dict) else {}\n    except Exception:\n        return {}\n\n\ndef build_description(base_description, state_payload):\n    text = base_description if isinstance(base_description, str) else ''\n    pattern = re.compile(rf\"\\n?{BLOCK_START}\\n.*?\\n{BLOCK_END}\\n?\", re.DOTALL)\n    clean = re.sub(pattern, \"\\n\", text).rstrip()\n    block = f\"{BLOCK_START}\\n{json.dumps(state_payload, ensure_ascii=False, sort_keys=True)}\\n{BLOCK_END}\"\n    if clean:\n        return clean + \"\\n\\n\" + block\n    return block\n\n\nitems = _input.all()\nif not items:\n    return []\n\nnow = datetime.now(timezone.utc).isoformat()\nout = []\nfor item in items:\n    payload = item.json if isinstance(item.json, dict) else {}\n    product_type_id = read_key(payload, 'product_type_id')\n    product_type = read_key(payload, 'product_type', {})\n    status = str(read_key(payload, 'workflow_status', 'ok') or 'ok')\n\n    description = read_key(product_type, 'description', '')\n    state_obj = parse_state(description)\n    counters = read_key(state_obj, 'counters', {})\n    if not isinstance(counters, dict):\n        counters = {}\n\n    subdomains_total = int(counters.get('subdomains_total', 0) or 0)\n    subdomains_done = int(counters.get('subdomains_done', 0) or 0)\n    subdomains_failed = int(counters.get('subdomains_failed', 0) or 0)\n    subdomains_running = int(counters.get('subdomains_running', 0) or 0)\n\n    if subdomains_total <= 0:\n        subdomains_total = max(1, subdomains_done + subdomains_failed + subdomains_running)\n\n    retry_count = int(read_key(state_obj, 'retry_count', 0) or 0)\n    last_error = read_key(payload, 'error_message')\n\n    if status == 'ok':\n        done_inc = max(1, subdomains_running)\n        subdomains_done += done_inc\n        subdomains_running = max(0, subdomains_running - done_inc)\n        counters['subdomains_success'] = int(counters.get('subdomains_success', 0) or 0) + 1\n        next_state = 'subdomains_done'\n        last_error = None\n    else:\n        failed_inc = max(1, subdomains_running)\n        subdomains_failed += failed_inc\n        subdomains_running = max(0, subdomains_running - failed_inc)\n        counters['subdomains_errors'] = int(counters.get('subdomains_errors', 0) or 0) + 1\n        next_state = 'error'\n        retry_count += 1\n\n    counters['subdomains_total'] = max(subdomains_total, subdomains_done + subdomains_failed + subdomains_running)\n    counters['subdomains_done'] = subdomains_done\n    counters['subdomains_failed'] = subdomains_failed\n    counters['subdomains_running'] = subdomains_running\n\n    updated_state = {\n        'version': int(read_key(state_obj, 'version', 1) or 1),\n        'state': next_state,\n        'counters': counters,\n        'last_update': now,\n        'retry_count': retry_count,\n        'last_error': last_error,\n        'last_stage': 'subdomains',\n        'lock_owner': None,\n        'lock_until': None,\n    }\n\n    out.append({\n        'json': {\n            'product_type_id': product_type_id,\n            'state': next_state,\n            'description': build_description(description, updated_state),\n            'domain': read_key(payload, 'domain'),\n            'workflow_status': status,\n        }\n    })\n\nreturn out\n"
      },
      "name": "Build PT State Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        208
      ],
      "id": "23a17734-a39b-481c-ac1b-a335fb1253c3"
    },
    {
      "parameters": {
        "method": "PATCH",
        "authentication": "headerAuth",
        "url": "={{ ($env.DOJO_BASE_URL || 'http://localhost:8080/api/v2').replace(/\\/+$/,'') + '/product_types/' + $json.product_type_id + '/' }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { description: $json.description } }}",
        "options": {}
      },
      "name": "Patch PT State in Dojo",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 1,
      "position": [
        408,
        208
      ],
      "id": "aa5e922a-3d80-4f53-8899-c2c693feec22",
      "credentials": {
        "httpHeaderAuth": {
          "id": "mGl4PbJkKfeJbTg8",
          "name": "Header Auth account"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Trigger": {
      "main": [
        [
          {
            "node": "Set Parameters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Parameters": {
      "main": [
        [
          {
            "node": "Get Product Type from Dojo",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Product Type from Dojo": {
      "main": [
        [
          {
            "node": "Extract Domain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Domain": {
      "main": [
        [
          {
            "node": "Run Subdomain Enumeration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Run Subdomain Enumeration": {
      "main": [
        [
          {
            "node": "Check Script Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Script Success": {
      "main": [
        [
          {
            "node": "Parse Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Handle Script Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Results": {
      "main": [
        [
          {
            "node": "Get Existing Products",
            "type": "main",
            "index": 0
          },
          {
            "node": "Generate Final Report",
            "type": "main",
            "index": 0
          },
          {
            "node": "Build PT State Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Existing Products": {
      "main": [
        [
          {
            "node": "Prepare Create List",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Create List": {
      "main": [
        [
          {
            "node": "Create Product in Dojo",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Script Error": {
      "main": [
        [
          {
            "node": "Build PT State Update",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build PT State Update": {
      "main": [
        [
          {
            "node": "Patch PT State in Dojo",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "5c441b20-1a9b-4a96-92d2-aa0b62ab0e4b",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "d06b9c37a455942c350bdf64d5764dfb5548ea5097bfb316251734323f35ea3f"
  },
  "id": "oZT7uy2mMk9QWkNi",
  "tags": []
}
